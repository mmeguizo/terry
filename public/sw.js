// RaceReady Service Worker - Racing-themed PWA
const CACHE_NAME = 'raceready-v1.0.0';
const OFFLINE_URL = '/offline';

// Racing-specific cache strategies
const CACHE_STRATEGIES = {
  // Critical racing data - cache first with network fallback
  RACE_CRITICAL: 'race-critical',
  // News and updates - network first with cache fallback  
  RACE_NEWS: 'race-news',
  // Static assets - cache first
  RACE_STATIC: 'race-static',
  // Images - cache first with long TTL
  RACE_IMAGES: 'race-images'
};

// URLs to cache on install (critical racing functionality)
const CRITICAL_CACHE_URLS = [
  '/',
  '/events',
  '/event-info', 
  '/offline',
  '/manifest.json',
  // Add critical CSS and JS (these will be generated by Next.js)
  '/_next/static/css/',
  '/_next/static/chunks/',
  // Critical racing icons
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png'
];

// Racing event patterns to cache
const RACING_PATTERNS = {
  api: /^\/api\/(config|events|news)/,
  events: /^\/events?\//,
  news: /^\/news\//,
  images: /\.(jpg|jpeg|png|gif|webp|svg)$/i,
  static: /\/_next\/static\//,
  fonts: /\.(woff|woff2|ttf|otf)$/i
};

// Install event - cache critical racing resources
self.addEventListener('install', (event) => {
  console.log('üèÅ RaceReady Service Worker installing...');
  
  event.waitUntil(
    (async () => {
      try {
        const cache = await caches.open(CACHE_NAME);
        
        // Cache critical resources
        await cache.addAll(CRITICAL_CACHE_URLS.filter(url => !url.includes('/_next/static/')));
        
        console.log('‚úÖ Critical racing resources cached');
        
        // Skip waiting to activate immediately
        self.skipWaiting();
      } catch (error) {
        console.error('‚ùå Failed to cache critical resources:', error);
      }
    })()
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('üèÅ RaceReady Service Worker activating...');
  
  event.waitUntil(
    (async () => {
      // Clean up old caches
      const cacheNames = await caches.keys();
      const oldCaches = cacheNames.filter(name => 
        name.startsWith('raceready-') && name !== CACHE_NAME
      );
      
      await Promise.all(
        oldCaches.map(cacheName => {
          console.log('üóëÔ∏è Deleting old cache:', cacheName);
          return caches.delete(cacheName);
        })
      );
      
      // Take control of all pages
      await clients.claim();
      console.log('‚úÖ RaceReady Service Worker activated');
    })()
  );
});

// Fetch event - implement racing-specific caching strategies
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Only handle same-origin requests
  if (url.origin !== location.origin) {
    return;
  }
  
  event.respondWith(handleRacingRequest(request));
});

// Racing-specific request handler
async function handleRacingRequest(request) {
  const url = new URL(request.url);
  const pathname = url.pathname;
  
  try {
    // API requests - network first with cache fallback
    if (RACING_PATTERNS.api.test(pathname)) {
      return await networkFirstStrategy(request, CACHE_STRATEGIES.RACE_CRITICAL);
    }
    
    // News pages - network first with cache fallback
    if (RACING_PATTERNS.news.test(pathname)) {
      return await networkFirstStrategy(request, CACHE_STRATEGIES.RACE_NEWS);
    }
    
    // Event pages - cache first with network fallback
    if (RACING_PATTERNS.events.test(pathname)) {
      return await cacheFirstStrategy(request, CACHE_STRATEGIES.RACE_CRITICAL);
    }
    
    // Images - cache first with long TTL
    if (RACING_PATTERNS.images.test(pathname)) {
      return await cacheFirstStrategy(request, CACHE_STRATEGIES.RACE_IMAGES);
    }
    
    // Static assets - cache first
    if (RACING_PATTERNS.static.test(pathname) || RACING_PATTERNS.fonts.test(pathname)) {
      return await cacheFirstStrategy(request, CACHE_STRATEGIES.RACE_STATIC);
    }
    
    // HTML pages - network first with offline fallback
    if (request.mode === 'navigate') {
      return await navigateStrategy(request);
    }
    
    // Default - network only
    return await fetch(request);
    
  } catch (error) {
    console.error('üö® Request failed:', pathname, error);
    
    // Return offline page for navigation requests
    if (request.mode === 'navigate') {
      const cache = await caches.open(CACHE_NAME);
      return await cache.match(OFFLINE_URL) || new Response('Offline', { status: 503 });
    }
    
    throw error;
  }
}

// Network first strategy - for dynamic racing data
async function networkFirstStrategy(request, cacheName) {
  const cache = await caches.open(cacheName);
  
  try {
    // Try network first
    const networkResponse = await fetch(request);
    
    // Cache successful responses
    if (networkResponse.ok) {
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    // Fallback to cache
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      console.log('üì± Serving cached racing data:', request.url);
      return cachedResponse;
    }
    throw error;
  }
}

// Cache first strategy - for static racing assets
async function cacheFirstStrategy(request, cacheName) {
  const cache = await caches.open(cacheName);
  
  // Try cache first
  const cachedResponse = await cache.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  
  // Fallback to network and cache
  try {
    const networkResponse = await fetch(request);
    if (networkResponse.ok) {
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  } catch (error) {
    console.error('üö® Failed to fetch and cache:', request.url, error);
    throw error;
  }
}

// Navigation strategy - for HTML pages
async function navigateStrategy(request) {
  try {
    // Try network first
    const networkResponse = await fetch(request);
    
    // Cache successful HTML responses
    if (networkResponse.ok) {
      const cache = await caches.open(CACHE_STRATEGIES.RACE_CRITICAL);
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    // Try cache
    const cache = await caches.open(CACHE_STRATEGIES.RACE_CRITICAL);
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      console.log('üì± Serving cached page:', request.url);
      return cachedResponse;
    }
    
    // Fallback to offline page
    return await cache.match(OFFLINE_URL) || new Response(
      generateOfflineHTML(),
      { 
        headers: { 'Content-Type': 'text/html' },
        status: 503
      }
    );
  }
}

// Generate racing-themed offline HTML
function generateOfflineHTML() {
  return `
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Offline - RaceReady</title>
      <style>
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
          color: white;
          margin: 0;
          padding: 20px;
          min-height: 100vh;
          display: flex;
          align-items: center;
          justify-content: center;
        }
        .container {
          text-align: center;
          max-width: 400px;
          padding: 40px 20px;
          background: rgba(255, 255, 255, 0.05);
          border-radius: 20px;
          border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .flag {
          font-size: 4rem;
          margin-bottom: 20px;
          animation: wave 2s ease-in-out infinite;
        }
        @keyframes wave {
          0%, 100% { transform: rotate(-10deg); }
          50% { transform: rotate(10deg); }
        }
        h1 {
          font-size: 2rem;
          margin-bottom: 10px;
          color: #3b82f6;
        }
        p {
          opacity: 0.8;
          line-height: 1.6;
          margin-bottom: 30px;
        }
        .retry-btn {
          background: #3b82f6;
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 8px;
          font-size: 1rem;
          cursor: pointer;
          transition: background 0.3s;
        }
        .retry-btn:hover {
          background: #2563eb;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="flag">üèÅ</div>
        <h1>You're Offline</h1>
        <p>No internet connection detected. Some racing data may not be up to date, but you can still browse cached content.</p>
        <button class="retry-btn" onclick="window.location.reload()">
          Try Again
        </button>
      </div>
    </body>
    </html>
  `;
}

// Background sync for race updates
self.addEventListener('sync', (event) => {
  if (event.tag === 'race-update-sync') {
    console.log('üèÅ Background sync: Updating race data...');
    event.waitUntil(syncRaceData());
  }
});

// Sync race data in background
async function syncRaceData() {
  try {
    // Fetch latest race data
    const endpoints = ['/api/config', '/api/events', '/api/news'];
    const cache = await caches.open(CACHE_STRATEGIES.RACE_CRITICAL);
    
    for (const endpoint of endpoints) {
      try {
        const response = await fetch(endpoint);
        if (response.ok) {
          await cache.put(endpoint, response.clone());
          console.log('‚úÖ Synced:', endpoint);
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to sync:', endpoint, error);
      }
    }
  } catch (error) {
    console.error('‚ùå Background sync failed:', error);
  }
}

// Push notifications for race updates
self.addEventListener('push', (event) => {
  if (!event.data) return;
  
  const data = event.data.json();
  const options = {
    body: data.body || 'New racing update available!',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    tag: data.tag || 'race-update',
    data: data.url || '/',
    actions: [
      {
        action: 'view',
        title: 'View Update',
        icon: '/icons/action-view.png'
      },
      {
        action: 'dismiss',
        title: 'Dismiss',
        icon: '/icons/action-dismiss.png'
      }
    ],
    vibrate: [200, 100, 200], // Racing pulse pattern
    requireInteraction: true
  };
  
  event.waitUntil(
    self.registration.showNotification(
      data.title || 'üèÅ RaceReady Update',
      options
    )
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  if (event.action === 'view') {
    const url = event.notification.data || '/';
    event.waitUntil(
      clients.openWindow(url)
    );
  }
});

console.log('üèÅ RaceReady Service Worker loaded successfully!');

